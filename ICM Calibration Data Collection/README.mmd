// Calibration void setup function for the ICM


#include <SPI.h>
#include "ICM45686.h"

#define IMU_CS   5   // IMU CS pin

ICM456xx IMU(SPI, IMU_CS);

#define TRIGGER_PIN 4

// Calibration offsets
float calibAccelX = 0;
float calibAccelY = 0;
float calibAccelZ = 0;
float calibGyroX = 0;
float calibGyroY = 0;
float calibGyroZ = 0;


// ---- Calibration function ----
void calibrateIMU(int samples) {
  long sumAx = 0, sumAy = 0, sumAz = 0;
  long sumGx = 0, sumGy = 0, sumGz = 0;

  Serial.println("Starting IMU calibration...");
  for (int i = 0; i < samples; i++) {
    inv_imu_sensor_data_t imu_data;
    IMU.getDataFromRegisters(imu_data);

    sumAx += imu_data.accel_data[0];
    sumAy += imu_data.accel_data[1];
    sumAz += imu_data.accel_data[2];
    sumGx += imu_data.gyro_data[0];
    sumGy += imu_data.gyro_data[1];
    sumGz += imu_data.gyro_data[2];

    delay(2); // small delay for ~500Hz
  }

  // Average raw values
  float avgAx = (float)sumAx / samples;
  float avgAy = (float)sumAy / samples;
  float avgAz = (float)sumAz / samples;
  float avgGx = (float)sumGx / samples;
  float avgGy = (float)sumGy / samples;
  float avgGz = (float)sumGz / samples;

  // Convert to real units
  calibAccelX = avgAx * 16.0 / 32768.0;
  calibAccelY = avgAy * 16.0 / 32768.0;
  calibAccelZ = avgAz * 16.0 / 32768.0;
  calibGyroX  = avgGx * 2000.0 / 32768.0;
  calibGyroY  = avgGy * 2000.0 / 32768.0;
  calibGyroZ  = avgGz * 2000.0 / 32768.0;

  Serial.println("Calibration complete:");
  Serial.printf("Accel offsets: %.6f, %.6f, %.6f\n", calibAccelX, calibAccelY, calibAccelZ);
  Serial.printf("Gyro  offsets: %.6f, %.6f, %.6f\n", calibGyroX, calibGyroY, calibGyroZ);
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Initialize VSPI
  SPI.begin(18, 19, 23); // SCK=18, MISO=19, MOSI=23

  // Initialize IMU
  if (IMU.begin() != 0) {
    Serial.println("ICM456xx initialization failed");
    while (1);
  }
  IMU.startAccel(1600, 16);   // 1600 Hz, ±16 g
  IMU.startGyro(1600, 2000);  // 1600 Hz, ±2000 dps

  // ---- Run Calibration ----
  Serial.println("Do Not move Drone while Calibrating.");
  calibrateIMU(1000);

  Serial.println("Entering Loop now!");
}

void loop() {

  inv_imu_sensor_data_t imu_data;
  IMU.getDataFromRegisters(imu_data);

  // Convert and subtract calibration offsets
  float ax = imu_data.accel_data[0] * 16.0 / 32768.0 - calibAccelX;
  float ay = imu_data.accel_data[1] * 16.0 / 32768.0 - calibAccelY;
  float az = imu_data.accel_data[2] * 16.0 / 32768.0 - calibAccelZ;
  float gx = imu_data.gyro_data[0] * 2000.0 / 32768.0 - calibGyroX;
  float gy = imu_data.gyro_data[1] * 2000.0 / 32768.0 - calibGyroY;
  float gz = imu_data.gyro_data[2] * 2000.0 / 32768.0 - calibGyroZ;

}
