#include <Arduino.h>
#include <TFT_eSPI.h>
#include <Wire.h>
#include <Bitcraze_PMW3901.h>

// Defining SPI pins
#define SPI_CS 10
#define SPI_MOSI 11
#define SPI_CLK 12
#define SPI_MISO 13
#define RST 3

TFT_eSPI tft = TFT_eSPI(170, 320); // Init screen size

// Using digital pin 10 for chip select
SPIClass SPI2(HSPI);
Bitcraze_PMW3901 flow(SPI_CS);

char frame[35*35]; //array to hold the framebuffer

int PixelScale = 4;


const PROGMEM uint16_t ironhot[] =  
{0x0000,0x0000,0x0000,0x0000,0x0000,0x0020,0x0020,
0x0020,0x0020,0x0020,0x0841,0x0841,0x0841,0x0841,
0x0841,0x0841,0x0861,0x0861,0x0861,0x0861,0x0861,
0x1082,0x1082,0x1082,0x1082,0x1082,0x10a2,0x10a2,
0x10a2,0x10a2,0x10a2,0x18c3,0x18c3,0x18c3,0x18c3,
0x18c3,0x18e3,0x18e3,0x18e3,0x18e3,0x18e3,0x2104,
0x2104,0x2104,0x2104,0x2104,0x2124,0x2124,0x2124,
0x2124,0x2124,0x2124,0x2945,0x2945,0x2945,0x2945,
0x2945,0x2965,0x2965,0x2965,0x2965,0x2965,0x3186,
0x3186,0x3186,0x3186,0x31a6,0x31a6,0x31a6,0x31a6,
0x31a6,0x39c7,0x39c7,0x39c7,0x39c7,0x39c7,0x39e7,
0x39e7,0x39e7,0x39e7,0x39e7,0x4208,0x4208,0x4208,
0x4208,0x4208,0x4228,0x4228,0x4228,0x4228,0x4228,
0x4a49,0x4a49,0x4a49,0x4a49,0x4a49,0x4a69,0x4a69,
0x4a69,0x4a69,0x4a69,0x528a,0x528a,0x528a,0x528a,
0x528a,0x52aa,0x52aa,0x52aa,0x52aa,0x52aa,0x5acb,
0x5acb,0x5acb,0x5acb,0x5acb,0x5aeb,0x5aeb,0x5aeb,
0x5aeb,0x5aeb,0x630c,0x630c,0x630c,0x630c,0x630c,
0x632c,0x632c,0x632c,0x632c,0x632c,0x632c,0x6b4d,
0x6b4d,0x6b4d,0x6b4d,0x6b4d,0x6b6d,0x6b6d,0x6b6d,
0x6b6d,0x6b6d,0x738e,0x738e,0x738e,0x738e,0x738e,
0x73ae,0x73ae,0x73ae,0x73ae,0x73ae,0x7bcf,0x7bcf,
0x7bcf,0x7bcf,0x7bcf,0x7bef,0x7bef,0x7bef,0x7bef,
0x7bef,0x7bef,0x8410,0x8410,0x8410,0x8410,0x8410,
0x8430,0x8430,0x8430,0x8430,0x8430,0x8c51,0x8c51,
0x8c51,0x8c51,0x8c51,0x8c71,0x8c71,0x8c71,0x8c71,
0x8c71,0x9492,0x9492,0x9492,0x9492,0x9492,0x94b2,
0x94b2,0x94b2,0x94b2,0x9cd3,0x9cd3,0x9cd3,0x9cd3,
0x9cd3,0x9cd3,0x9cf3,0x9cf3,0x9cf3,0x9cf3,0x9cf3,
0xa514,0xa514,0xa514,0xa514,0xa514,0xa534,0xa534,
0xa534,0xa534,0xa534,0xad55,0xad55,0xad55,0xad55,
0xad55,0xad75,0xad75,0xad75,0xad75,0xb596,0xb596,
0xb5b6,0xb5b6,0xb5b6,0xbdd7,0xbdd7,0xbdd7,0xbdf7,
0xbdf7,0xbdf7,0xc618,0xc618,0xc638,0xc638,0xc638,
0xce59,0xce59,0xce59,0xce79,0xce79,0xd69a,0xd69a,
0xd69a,0xd6ba,0xd6ba,0xd6ba,0xdedb,0xdedb,0xdefb,
0xdefb,0xdefb,0xe71c};

void setup() {
  SPI2.begin(SPI_CLK, SPI_MISO, SPI_MOSI, SPI_CS);
  Serial.begin(115200);

  tft.init();
  tft.setRotation(1);
  tft.setTextSize(2);
  tft.setTextDatum(MC_DATUM);
  tft.fillScreen(TFT_RED);
  tft.setTextColor(TFT_WHITE);

  if (!flow.begin()) {
    tft.print("Initialization of the flow sensor failed");
    while(1) { }
  }
  else {
    tft.print("Initialization of the flow sensor suceeded");
  }

  delay(2000);
  tft.fillScreen(TFT_BLACK);

  flow.enableFrameBuffer(); 
}

int16_t deltaX = 0;
int16_t deltaY = 0;

void loop() {
  flow.readFrameBuffer(frame);
  int i,j,k;
  for(i=0, k=0; i<35; i++){ //i is Y pixel pos
    for(j=0; j<35; j++, k++){  //j is X pixel pos
      uint8_t colorIndex = frame[k];
      //draw the pixels!
      tft.fillRect(4+PixelScale * i, 4+PixelScale * j, PixelScale, PixelScale, ironhot[colorIndex]); //Scale up function to fill screen
      }
  }

  tft.setCursor(150, 0);
  tft.setTextColor(TFT_BLACK);
  tft.print("X: ");
  tft.println(deltaX);

  tft.setCursor(150, 20);
  tft.print("Y: ");
  tft.print(deltaY);

  // Get motion count since last call
  flow.readMotionCount(&deltaX, &deltaY);

  tft.setCursor(150, 0);
  tft.setTextColor(TFT_WHITE);
  tft.print("X: ");
  tft.println(deltaX);

  tft.setCursor(150, 20);
  tft.print("Y: ");
  tft.print(deltaY);  
}